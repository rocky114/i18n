package i18n

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"io/fs"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

type generator struct {
	path     string
	buf      bytes.Buffer
	values   map[string][]value
	language []string
}

type value struct {
	val    string
	name   string
	length int
}

func New(path string) *generator {
	return &generator{
		path:   path,
		buf:    bytes.Buffer{},
		values: make(map[string][]value),
	}
}

func (g *generator) Generate() {
	err := g.parse()
	if err != nil {
		log.Fatalln(err)
	}

	g.output()
}

func (g *generator) printf(format string, args ...interface{}) {
	_, _ = fmt.Fprintf(&g.buf, format, args...)
}

const tranFuncStr = `
func Translate(local string, index int, args ...string) string {
%s
	return ""
}
`

func (g *generator) output() {
	var nameBuilder strings.Builder
	var valBuilder strings.Builder
	var indexBuilder strings.Builder
	var funcBuilder strings.Builder

	for index, lang := range g.language {
		valBuilder.WriteString(fmt.Sprintf("\t%sStr = \"", lang))
		indexBuilder.WriteString(fmt.Sprintf("\t%sIndex = []uint{0", lang))

		numIndex := 0
		for i, item := range g.values[lang] {
			if index == 0 {
				if i == 0 {
					nameBuilder.WriteString(fmt.Sprintf("\t%s = iota\n", item.name))
				} else {
					nameBuilder.WriteString(fmt.Sprintf("\t%s\n", item.name))
				}
			}

			numIndex += item.length

			valBuilder.WriteString(item.val)
			indexBuilder.WriteString(fmt.Sprintf(", %d", numIndex))
		}
		valBuilder.WriteString("\"\n")
		indexBuilder.WriteString("}\n")

		funcBuilder.WriteString(fmt.Sprintf("\tif local == \"%s\" {\n\t\treturn %sStr[%sIndex[index]:%sIndex[index+1]]\n\t}\n", lang, lang, lang, lang))
	}

	// Print the header and package clause.
	g.printf("// Code generated by automake; DO NOT EDIT.\n")
	g.printf("\n")
	g.printf("package i18n\n")
	g.printf("\n")
	g.printf("const (\n%s)\n\n", nameBuilder.String())
	g.printf("const (\n%s)\n\n", valBuilder.String())
	g.printf("var (\n%s)\n\n", indexBuilder.String())

	g.printf(fmt.Sprintf(tranFuncStr, funcBuilder.String()))


	filename := filepath.Dir(g.path) + fmt.Sprint("/langstring.go")
	err := ioutil.WriteFile(filename, g.buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
}

func (g *generator) parse() error {
	err := filepath.Walk(g.path, func(path string, info fs.FileInfo, err error) error {
		if g.path == path {
			return nil
		}

		if filepath.Ext(path) != ".toml" {
			return errors.New("invalid i18n file")
		}

		lang := strings.TrimSuffix(filepath.Base(path), ".toml")
		g.language = append(g.language, lang)

		f, err := os.Open(path)
		if err != nil {
			return err
		}

		scanner := bufio.NewScanner(f)
		for scanner.Scan() {
			text := scanner.Text()
			if text[0] == '#' || len(text) == 0 {
				continue
			}

			strSlice := strings.Split(scanner.Text(), "=")
			key := strings.Trim(strings.TrimSpace(strSlice[0]), "\"")

			val := strSlice[1]
			if index := strings.Index(strSlice[1], "#"); index != -1 {
				val = val[:index]
			}
			val = strings.Trim(strings.TrimSpace(val), "\"")

			g.values[lang] = append(g.values[lang], value{
				val:    val,
				length: len(val),
				name:   CamelString(key),
			})
		}
		return nil
	})

	return err
}

func CamelString(name string) string {
	length := len(name)

	isUpper := false
	data := make([]byte, 0)
	for i := 0; i < length; i++ {
		c := name[i]
		if c >= 'A' && c <= 'Z' {
			data = append(data, c)
			continue
		}
		if c == '_' {
			isUpper = true
			continue
		}
		if i == 0 {
			isUpper = true
		}
		if isUpper {
			data = append(data, c-32)
		} else {
			data = append(data, c)
		}

		isUpper = false
	}

	return string(data)
}
